(print "loadup.bel")

(def reduce1 (f xs)
  (if (no (cdr xs))
      (car xs)
      (f (car xs) (reduce1 f (cdr xs)))))

(def map1 (f . ls)
  (if (no ls)       nil
      (some no ls)  nil
      (no (cdr ls)) (cons (f (car (car ls)))
                          (map1 f (cdr (car ls))))
                    (cons (apply f (map1 car ls))
                          (apply map1 f (map1 cdr ls)))))

(mac or args
  (if (no args)
      nil
      (let v (uvar 'or_v)
        (list 'let v (car args)
          (list 'if v v (cons 'or (cdr args)))))))
        ;`(let ,v ,(car args)
        ;   (if ,v ,v (or ,@(cdr args)))))))

(mac and args
  (reduce1 (fn es (cons 'if es))
           (or args '(t))))

(mac with (parms . body)
  (let ps (hug parms)
    ;`((fn ,(map car ps) ,@body)
    ;  ,@(map cadr ps))))
    (cons (append (list 'fn (map car ps)) body)
          (map cadr ps))))


(mac bquote (e)
  (let (sub change) (bqex e nil)
    (if change sub (list 'quote e))))

(mac quasiquote (e)
  (list 'bquote e))

(def bqex (e n)
  (if (no e)   (list nil nil)
      (atom e) (list (list 'quote e) nil)
               (case (car e)
                 bquote   (bqthru e (list n) 'bquote)
                 comma    (if (no n)
                              (list (cadr e) t)
                              (bqthru e (car n) 'comma))
                 comma-at (if (no n)
                              (list (list 'splice (cadr e)) t)
                              (bqthru e (car n) 'comma-at))
                 unquote  (if (no n)
                              (list (cadr e) t)
                              (bqthru e (car n) 'unquote))
                 unquote-splicing
                          (if (no n)
                              (list (list 'splice (cadr e)) t)
                              (bqthru e (car n) 'unquote-splicing))
                          (bqexpair e n))))

(def bqthru (e n op)
  (let (sub change) (bqex (cadr e) n)
    (if change
        (list (if (caris sub 'splice)
                  ;`(cons ',op ,(cadr sub))
                  ;`(list ',op ,sub)
                  (list 'cons (list 'quote op) (cadr sub))
                  (list 'list (list 'quote op) sub)
                  )
              t)
        (list (list 'quote e) nil))))

(def bqexpair (e n)
  (with ((a achange) (bqex (car e) n)
         (d dchange) (bqex (cdr e) n))
    (if (or achange dchange)
        (list (if (caris d 'splice)
                  (if (caris a 'splice)
                      ;`(apply append (spa ,(cadr a)) (spd ,(cadr d)))
                      ;`(apply cons ,a (spd ,(cadr d)))
                      (list 'apply 'append (list 'spa (cadr a)) (list 'spd (cadr d)))
                      (list 'apply 'cons a (list 'spd (cadr d)))
                      )
                  (caris a 'splice)
                  ;`(append (spa ,(cadr a)) ,d)
                  ;`(cons ,a ,d)
                  (list 'append (list 'spa (cadr a)) d)
                  (list 'cons a d)
                  )
              t)
        (list (list 'quote e) nil))))

(def spa (x)
  (if (and x (atom x))
      (err 'splice-atom)
      x))

(def spd (x)
  (pcase x
    no   (err 'splice-empty-cdr)
    atom (err 'splice-atom)
    cdr  (err 'splice-multiple-cdrs)
         x))

(mac comma args
  '(err 'comma-outside-backquote))

(mac comma-at args
  '(err 'comma-at-outside-backquote))

(mac splice args
  '(err 'comma-at-outside-list))

(mac unquote args
  '(err 'unquote-outside-backquote))

(mac unquote-splicing args
  '(err 'unquote-splicing-outside-backquote))

(def con (x)
  (fn args x))

(def compose fs
  (reduce (fn (f g)
            (fn args (f (apply g args))))
          (or fs (list idfn))))

(def combine (op)
  (fn fs
    (reduce1 (fn (f g)
               (fn args
                 (op (apply f args) (apply g args))))
             (or fs (list (con (op)))))))

(set cand (combine and)
     cor  (combine or))

(def fuse (f . args)
  (apply append (apply map1 f args)))

(mac letu (v . body)
  (if ((cor variable atom) v)
      `(let ,v (uvar) ,@body)
      `(with ,(fuse [list _ '(uvar)] v)
         ,@body)))

(mac catch body
  (letu v
    `(ccc (fn (,v) (bind throw ,v ,@body)))))

(def write (x)
  (print (prrepr x)))

(print "done")
